"""
Property-based tests for test data generators.
These are meta-tests that validate the generators themselves produce valid data.

**Feature: phase3-property-testing**
"""

import ast
import re
import json
from hypothesis import given, settings, HealthCheck
import pytest

from tests.test_generators import (
    generate_git_url,
    generate_python_code,
    generate_dependency_spec,
    generate_file_tree,
)
from services.repository_ingester import RepositoryIngester


class TestURLGeneratorValidity:
    """Test that the URL generator produces valid URLs."""
    
    @given(url=generate_git_url())
    @settings(max_examples=100)
    def test_generated_urls_pass_validation(self, url):
        """
        **Feature: phase3-property-testing, Property 19: Generator URL Validity**
        **Validates: Requirements 7.1**
        
        Property: For any URL generated by generate_git_url(), 
        it should pass the repository ingester's URL validation.
        
        This is a meta-test that validates the generator itself.
        """
        ingester = RepositoryIngester()
        
        # The generated URL should pass validation
        assert ingester.validate_url(url), \
            f"Generated URL failed validation: {url}"
    
    @given(url=generate_git_url())
    @settings(max_examples=100)
    def test_generated_urls_match_expected_patterns(self, url):
        """
        Additional validation that generated URLs match expected Git URL patterns.
        """
        # Patterns for valid Git URLs
        https_pattern = r'^https://[a-z0-9.-]+/[a-z0-9-]+/[a-z0-9._-]+\.git$'
        git_pattern = r'^git://[a-z0-9.-]+/[a-z0-9-]+/[a-z0-9._-]+\.git$'
        ssh_pattern = r'^git@[a-z0-9.-]+:[a-z0-9-]+/[a-z0-9._-]+\.git$'
        
        # URL should match at least one pattern
        matches = (
            re.match(https_pattern, url) or
            re.match(git_pattern, url) or
            re.match(ssh_pattern, url)
        )
        
        assert matches, \
            f"Generated URL doesn't match expected patterns: {url}"


class TestPythonCodeGeneratorValidity:
    """Test that the Python code generator produces valid parseable code."""
    
    @given(code=generate_python_code())
    @settings(max_examples=100, suppress_health_check=[HealthCheck.too_slow])
    def test_generated_code_is_parseable(self, code):
        """
        **Feature: phase3-property-testing, Property 20: Generator Python Syntax Validity**
        **Validates: Requirements 7.2**
        
        Property: For any Python code generated by generate_python_code(),
        it should be parseable by Python's ast.parse() without syntax errors.
        
        This is a meta-test that validates the generator itself.
        """
        try:
            ast.parse(code)
        except SyntaxError as e:
            pytest.fail(
                f"Generated code has syntax error:\n"
                f"Code:\n{code}\n"
                f"Error: {e}"
            )
    
    @given(code=generate_python_code())
    @settings(max_examples=100, suppress_health_check=[HealthCheck.too_slow])
    def test_generated_code_produces_valid_ast(self, code):
        """
        Additional validation that generated code produces a valid AST.
        """
        tree = ast.parse(code)
        
        # The AST should not be empty
        assert tree is not None, "Generated code produced None AST"
        
        # The AST should be a Module
        assert isinstance(tree, ast.Module), \
            f"Generated code produced {type(tree)}, expected ast.Module"


class TestDependencyGeneratorValidity:
    """Test that the dependency generator produces valid dependency specifications."""
    
    @given(dep=generate_dependency_spec(format_type='pip'))
    @settings(max_examples=100)
    def test_generated_pip_dependencies_match_format(self, dep):
        """
        **Feature: phase3-property-testing, Property 21: Generator Dependency Format Validity**
        **Validates: Requirements 7.3**
        
        Property: For any pip dependency generated by generate_dependency_spec(format_type='pip'),
        it should match the expected pip format (package==1.0.0, package>=1.0.0, etc.).
        
        This is a meta-test that validates the generator itself.
        """
        # Pattern for pip dependencies: package==1.0.0, package>=1.0.0, etc.
        pip_pattern = r'^[a-z][a-z0-9_-]*[a-z0-9](==|>=|~=|<=|>)\d+\.\d+\.\d+$'
        
        assert re.match(pip_pattern, dep), \
            f"Generated pip dependency doesn't match expected format: {dep}"
    
    @given(dep=generate_dependency_spec(format_type='npm'))
    @settings(max_examples=100)
    def test_generated_npm_dependencies_match_format(self, dep):
        """
        Property: For any npm dependency generated by generate_dependency_spec(format_type='npm'),
        it should match the expected npm format ("package": "^1.0.0").
        """
        # Pattern for npm dependencies: "package": "^1.0.0"
        npm_pattern = r'^"[a-z][a-z0-9_-]*[a-z0-9]": "[\^~]?\d+\.\d+\.\d+"$'
        
        assert re.match(npm_pattern, dep), \
            f"Generated npm dependency doesn't match expected format: {dep}"
    
    @given(dep=generate_dependency_spec(format_type='poetry'))
    @settings(max_examples=100)
    def test_generated_poetry_dependencies_match_format(self, dep):
        """
        Property: For any poetry dependency generated by generate_dependency_spec(format_type='poetry'),
        it should match the expected poetry format (package = "^1.0.0").
        """
        # Pattern for poetry dependencies: package = "^1.0.0"
        poetry_pattern = r'^[a-z][a-z0-9_-]*[a-z0-9] = "[\^~]?\d+\.\d+\.\d+"$'
        
        assert re.match(poetry_pattern, dep), \
            f"Generated poetry dependency doesn't match expected format: {dep}"
    
    @given(dep=generate_dependency_spec(format_type='pip'))
    @settings(max_examples=100)
    def test_generated_pip_dependencies_have_valid_version(self, dep):
        """
        Additional validation that pip dependencies have valid semantic versions.
        """
        # Extract version from dependency
        version_match = re.search(r'(\d+)\.(\d+)\.(\d+)$', dep)
        assert version_match, f"Could not extract version from: {dep}"
        
        major, minor, patch = version_match.groups()
        
        # Versions should be non-negative integers
        assert int(major) >= 0, f"Invalid major version in: {dep}"
        assert int(minor) >= 0, f"Invalid minor version in: {dep}"
        assert int(patch) >= 0, f"Invalid patch version in: {dep}"


class TestDirectoryTreeGeneratorValidity:
    """Test that the directory tree generator produces valid structures."""
    
    @given(tree=generate_file_tree())
    @settings(max_examples=100, suppress_health_check=[HealthCheck.too_slow])
    def test_generated_trees_have_valid_paths(self, tree):
        """
        **Feature: phase3-property-testing, Property 22: Generator Directory Tree Validity**
        **Validates: Requirements 7.4**
        
        Property: For any directory structure generated by generate_file_tree(),
        all paths should be valid (no invalid characters, no path traversal).
        
        This is a meta-test that validates the generator itself.
        """
        # Invalid path characters that should not appear
        invalid_chars = '<>:"|?*\x00'
        
        def validate_tree(subtree, path=""):
            """Recursively validate the file tree structure."""
            assert isinstance(subtree, dict), \
                f"Tree should be a dict at {path}, got {type(subtree)}"
            
            for name, content in subtree.items():
                # Check for invalid characters
                for char in invalid_chars:
                    assert char not in name, \
                        f"Invalid character '{char}' in name: {name} at {path}"
                
                # Check name is not empty
                assert len(name) > 0, f"Empty name in tree at {path}"
                
                # Check for path traversal
                assert '..' not in name, \
                    f"Path traversal detected in name: {name} at {path}"
                
                # Check if it's a file or directory
                if isinstance(content, str):
                    # It's a file - should have an extension
                    assert '.' in name, \
                        f"File should have extension: {name} at {path}"
                    
                    extension = name.split('.')[-1]
                    valid_extensions = ['py', 'js', 'ts', 'jsx', 'tsx', 'txt', 'md']
                    assert extension in valid_extensions, \
                        f"File has unexpected extension: {name} at {path}"
                
                elif isinstance(content, dict):
                    # It's a directory - recursively validate
                    import os
                    validate_tree(content, os.path.join(path, name))
                
                else:
                    pytest.fail(
                        f"Unexpected content type at {path}/{name}: {type(content)}"
                    )
        
        validate_tree(tree)
    
    @given(tree=generate_file_tree())
    @settings(max_examples=100, suppress_health_check=[HealthCheck.too_slow])
    def test_generated_trees_have_no_absolute_paths(self, tree):
        """
        Additional validation that generated trees don't contain absolute paths.
        """
        def check_no_absolute_paths(subtree, path=""):
            """Recursively check for absolute paths."""
            for name, content in subtree.items():
                # Check name doesn't start with path separators
                assert not name.startswith('/'), \
                    f"Absolute path detected: {name} at {path}"
                assert not name.startswith('\\'), \
                    f"Absolute path detected: {name} at {path}"
                
                # Check for drive letters (Windows)
                assert not re.match(r'^[A-Za-z]:', name), \
                    f"Drive letter detected: {name} at {path}"
                
                # Recursively check subdirectories
                if isinstance(content, dict):
                    import os
                    check_no_absolute_paths(content, os.path.join(path, name))
        
        check_no_absolute_paths(tree)
    
    @given(tree=generate_file_tree())
    @settings(max_examples=100, suppress_health_check=[HealthCheck.too_slow])
    def test_generated_trees_are_not_empty(self, tree):
        """
        Additional validation that generated trees are not empty.
        """
        # Tree should have at least one item
        assert len(tree) > 0, "Generated tree is empty"
        
        # Count total items (files and directories)
        def count_items(subtree):
            count = len(subtree)
            for content in subtree.values():
                if isinstance(content, dict):
                    count += count_items(content)
            return count
        
        total_items = count_items(tree)
        assert total_items > 0, "Generated tree has no items"
